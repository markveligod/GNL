---------------------------------------------------------------------
Теперь вы начинаете понимать, что будет сложно читать данные из файлового дескриптора, если вы заранее не знаете его размер. Каким должен быть размер вашего буфера? Как
много раз вам нужно прочитать файловый дескриптор, чтобы получить данные ?
Это совершенно нормально и естественно, что, будучи программистом, вы хотели бы прочитать
“строка", которая заканчивается разрывом строки из файлового дескриптора. Например, каждая команда, которая
вы вводите свою оболочку или каждую строку, считанную из плоского файла.
Благодаря проекту get_next_line, Вы наконец-то сможете написать функцию
это позволит вам прочитать строку, заканчивающуюся символом новой строки из файлового дескриптора.
----------------------------------------------------------------------
Этот проект позволит вам не только добавить в свою коллекцию очень удобную функцию,
но это также позволит вам изучить очень интересную новую концепцию в программировании на языке Си:
статическая переменная.
Вы также получите более глубокое понимание распределений, независимо от того, происходят ли они на самом деле.
память стека или в памяти кучи, манипуляции и жизненный цикл буфера,
неожиданная сложность подразумевается при использовании одной или нескольких статических переменных.
Ваше уважение к норме улучшит строгость вашего программирования. Мы тоже подозреваем
что ваш подход к кодированию изменится, когда вы обнаружите, что начальное состояние
переменная в функции может изменяться в зависимости от вызова этой самой функции.
------------------------------------------------------------------------
Вы должны отправить только два файла: get_next_line.C и get_next_line.х
* * Если вы умны, вы будете использовать свой лифт. Если это так, Отправьте свой лифт папок в корень
из вашего хранилища.
• В вашей программе не может быть основной функции.
• Не нажимайте файл Makefile.
• Ваш проект должен быть написан в соответствии с нормой.
• Вы должны тщательно обрабатывать ошибки. Ни в коем случае ваша программа, или в данном конкретном случае ваша функция, не может выйти неожиданным образом (ошибка сегментации, шина
ошибка, двойное свободное и т. д.).
• При необходимости все выделенное в куче место памяти должно быть надлежащим образом освобождено.
• Ваш проект не может протекать.
• Вы должны отправить файл под названием author, содержащий ваше имя пользователя, за которым следует буква "\n".
в корневом каталоге репозитория:
-----------------------------------------------------------------------------
Если вы решите отправить этот проект с помощью вашего библиотечного лифта, это строго запрещено
чтобы обойти ограничение нормы путем добавления некоторых специфических функций из вашего
get_next_line. Это будет считаться мошенничеством во время вашей защиты. Ваш
get_next_line должен содержать в себе 5 функций по 25 строк макс. Уважение к этому
инструкции будут тщательно проверены во время вашей защиты. В тебе нет никакой необходимости
попросите разрешения у персонала добавить функцию в вашу библиотеку. Вместо этого используй свою голову
и спросите себя, уважает ли ваша функция эту инструкцию. Если ты все сделаешь правильно,
конечно, вам будет предложено расширить свою библиотеку с помощью универсальных функций.
Вы обнаружите их использование по мере завершения этого проекта.
• Функции libc, разрешенные в этом проекте, являются read, malloc и free.
------------------------------------------------------------------------------
* Напишите функцию, которая возвращает строку, считанную из файлового дескриптора.
• То, что мы называем “линией", - это последовательность символов, которые заканчиваются на ’\n '(код ascii
0x0a) или с концом файла (EOF).
Первый параметр - это файловый дескриптор, который будет использоваться для чтения.
* Второй параметр - это адрес указателя на символ, который будет использоваться
чтобы сохранить строку, считанную из файлового дескриптора.
* Возвращаемое значение может быть 1, 0 или -1 в зависимости от того, была ли прочитана строка,
когда чтение было завершено, или если произошла ошибка соответственно.
• Ваша функция get_next_line должна возвращать свой результат без ’\n'.
• Вызов вашей функции get_next_line в цикле позволит вам прочитать текст
доступно в файловом дескрипторе по одной строке за раз до конца текста, не важно
размер текста или одной из его строк.
• Убедитесь, что ваша функция ведет себя хорошо, когда она читает из файла, из
стандартный вывод, от перенаправления и т. д.
• В вашем заголовочном файле get_next_line.h у вас должен быть по крайней мере прототип
функция get_next_line и макрос, позволяющий выбрать размер буфера считывания для функции read. Это значение будет изменено во время защиты на
оцените силу своей функции. Этот макрос должен быть назван BUFF_SIZE.
Например:
#define BUFF_SIZE 32
-----------------------------------------------------------------------------------
Мы считаем, что get_next_line имеет неопределенное поведение, если между двумя вызовами,
один и тот же файловый дескриптор создает два разных файла, хотя чтение из первого
файл не был завершен.
• Мы также считаем, что вызов lseek(2) никогда не будет иметь место между двумя вызовами lseek (2).
функция get_next_line находится в том же файловом дескрипторе.
• Наконец, мы считаем, что get_next_line имеет неопределенное поведение при чтении
из двоичного файла. Однако, если вы хотите, вы можете сделать это поведение последовательным.
* Глобальные переменные запрещены.
* Статические переменные разрешены.
-------------------------------------------------------------------------------------
Бонус
-------------------------------------------------------------------------------------
Проект get_next_line работает прямолинейно и оставляет очень мало места для бонусов,
но я уверен, что у вас богатое воображение. Если вы туз совершенно обязательный
часть, то во что бы то ни стало завершите эту бонусную часть, чтобы идти дальше. Повторяю, никакого бонуса не будет
принимается во внимание, если обязательная часть не является совершенной.
• Для успешного выполнения get_next_line с одной статической переменной.
• Чтобы иметь возможность управлять несколькими файловыми дескрипторами с помощью get_next_line. Например, если файловые дескрипторы 3, 4 и 5 доступны для чтения, то можно вызвать
get_next_line раз по 3, один раз на 4, опять на 3 потом еще на 5 и т. д. без
потеря потока чтения для каждого из дескрипторов.
