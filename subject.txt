--------------------------------------------------------------------------------------------------------------------------------------------------
Этот проект не только позволит вам добавить очень удобную функцию в вашу коллекцию,
но и позволит вам изучить очень интересную новую концепцию в программировании на языке Си: статические переменные.
---------------------------------------------------------------------------------------------------------------------------------------------------
Ваш проект должен быть написан в соответствии с нормой. Если у вас есть бонус
файлы / функции, они включены в проверку нормы, и вы получите 0, если внутри есть ошибка нормы.
• Ваши функции не должны выходить неожиданно (ошибка сегментации, ошибка шины, двойная свобода и т. д.), Кроме неопределенного поведения. 
Если это произойдет, ваш проект будет считаться нефункциональным и получит 0 во время оценки.
• При необходимости все выделенное в куче место памяти должно быть надлежащим образом освобождено. Никакие утечки не будут допущены.
• Если субъект требует этого, вы должны представить файл Makefile, который будет компилировать ваши данные.
исходные файлы к требуемому выходу с флагами-Wall, - Wextra и-Werror, а также
ваш Makefile не должен повторно связываться.
• Ваш Makefile должен, по крайней мере, содержать правила $(NAME), all, clean, fclean и re.
• Чтобы включить бонусы в свой проект, вы должны включить бонус правила в свой Makefile, который добавит все различные заголовки, 
librairies или функции, запрещенные в основной части проекта. Бонусы должны быть в другом файле _bonus.{з/з}. Обязательная и бонусная часть оценки проводится отдельно.
• Если ваш проект позволяет вам использовать ваш libft, вы должны скопировать его исходные тексты и
связанный файл Makefile в папке libft с соответствующим файлом Makefile. Это ваш проект
Makefile должен скомпилировать библиотеку, используя ее Makefile, а затем скомпилировать проект.
• Мы рекомендуем вам создавать тестовые программы для вашего проекта, даже если эта работа не будет представлена и не будет оценена. Это даст вам шанс
чтобы легко проверить свою работу и работу ваших коллег. Вы найдете эти тесты особенно
полезно во время вашей защиты. Действительно, во время защиты вы можете свободно использовать свои тесты и/или тесты оцениваемого вами коллеги.
* Отправьте свою работу в назначенный вам репозиторий git. Оцениваться будет только работа в репозитории git. Если глубокая мысль назначена для оценки вашей работы, 
это будет сделано после ваших коллегиальных оценок. Если в любом разделе вашей работы во время оценки deepthought произойдет ошибка, оценка будет остановлена.
-----------------------------------------------------------------------------------------------------------------------------------------------------
• Вызов вашей функции get_next_line в цикле позволит вам прочитать текст
доступно в файловом дескрипторе по одной строке за раз до момента EOF.
• Убедитесь, что ваша функция ведет себя хорошо, когда она читает из файла и когда она
считывает данные со стандартного входного сигнала.
**Libft не разрешен для этого проекта. Вы должны добавить get_next_line_utils.C файл
который будет содержать функции, необходимые для работы вашего get_next_line.
• Ваша программа должна компилироваться с флагом-D BUFFER_SIZE=xx. который будет использоваться в качестве размера буфера для вызовов чтения в вашем get_next_line. Это значение будет равно
доработано вашими оценщиками и moulinette.
* Компиляция будет выполнена следующим образом : gcc-Wall-Wextra-Werror-D BUFFER_SIZE=32
get_next_line.с get_next_line_utils.с
• Ваше чтение должно использовать BUFFER_SIZE, определенный во время компиляции, чтобы читать из
файла или с клавиатуры.
• В заголовочном файле get_next_line.h у вас должен быть по крайней мере прототип
функция get_next_line.
----------------------------------------------------------------------------------------------------------------------------------------------------------
Имя функции: get_next_line
Прототип: int get_next_line(int fd, char **line);
Включите files - > get_next_line.с, get_next_line_utils.с, get_next_line.h
Значение ->
1: была прочитана строка
0 : EOF был достигнут
-1: произошла ошибка
Внешняя функция.: read, malloc, free
Описание: напишите функцию, которая возвращает строку, считанную из файлового дескриптора, без новой строки.
----------------------------------------------------------------------------------------------------------------------------------------------------------
Работает ли ваша функция по-прежнему, если значение BUFFER_SIZE равно 9999? И
если значение BUFFER_SIZE равно 1? А 10000000? А вы знаете, почему?

Вы должны стараться читать как можно меньше каждый раз get_next_line
призванный. Если вы столкнулись с новой строкой, вы должны вернуть текущую строку. Не считывайте весь файл, а затем обрабатывайте каждую строку.

Не сдавайте свой проект без тестирования. Есть много тестов, чтобы запустить, покрыть ваши базы. 
Попробуйте читать из файла, из перенаправления, из стандартного ввода. Как ведет себя ваша программа, когда вы отправляете новую строку в стандартный вывод? А CTRL-D?
----------------------------------------------------------------------------------------------------------------------------------------------------------
Мы считаем, что get_next_line имеет неопределенное поведение, если между двумя вызовами один и тот же файловый дескриптор переключается в другой файл до достижения EOF на первом fd.
• lseek не является разрешенной функцией. Чтение файла должно быть выполнено только один раз.
• Наконец, мы считаем, что get_next_line имеет неопределенное поведение при чтении
из двоичного файла. Однако, если вы хотите, вы можете сделать это поведение последовательным.
* Глобальные переменные запрещены.